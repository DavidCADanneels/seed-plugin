import java.util.regex.Pattern

ext {
    getPublishedPort = { String cid, int port ->
        new ByteArrayOutputStream().withStream { os ->
            exec {
                executable = 'docker'
                args = ['port', cid, port]
                standardOutput = os
            }
            def output = os.toString().trim()
            def m = Pattern.compile(/^.*:(\d+)$/).matcher(output)
            if (m.matches()) {
                m.group(1) as int
            } else {
                throw new GradleException("Cannot parse port from ${output}")
            }

        }
    }
}

task dockerDeploy(type: Exec, dependsOn: [buildLatest, ':seed-pipeline-demo:assemble']) {
    executable 'docker'
    args = [
            'run',
            '--detach',
            '--publish-all=true',
            // Less memory needed for the tests
            '--env=JAVA_OPTS=-Xmx1024m',
            // List of tests file to mount
            "--volume=${projectDir}/src/test/resources/acceptance:/var/test/resources",
            // Mounting the Seed pipeline demo as a flat repository
            "--volume=${project(':seed-pipeline-demo').buildDir}/libs:/var/test/repository",
            // Image to deploy
            "nemerosa/seed:latest"
    ]
    standardOutput = new ByteArrayOutputStream()
    ext.cid = {
        standardOutput.toString().trim()
    }
    doLast {
        def cid = ext.cid()
        int port = getPublishedPort(cid, 8080)
        println "Deploying container ${cid} on port ${port}"
        project.ext.jenkinsPort = port
    }
}

// Use the -x dockerUndeploy flag to keep the container at the end of the tests
task dockerUndeploy(dependsOn: dockerDeploy) {
    doFirst {
        def cid = dockerDeploy.ext.cid()
        println "Undeploying container ${cid}"
        exec {
            executable = 'docker'
            args = ['rm', '--force', cid]
        }
    }
}

task dockerLogs(dependsOn: dockerDeploy) {
    doFirst {
        def cid = dockerDeploy.ext.cid()
        println "Getting logs from container ${cid}"
        def bytes = new ByteArrayOutputStream()
        exec {
            executable = 'docker'
            args = ['logs', cid]
            standardOutput = bytes
            errorOutput = bytes
        }
        new File(buildDir, 'jenkins.log').bytes = bytes.toByteArray()
    }
}

// Test repositories

class SvnRepo {

    private final Project project
    private final String svnUrl
    private final String path
    private final String wd

    SvnRepo(Project project, String path) {
        this(project, 'svn://localhost', path)
    }

    SvnRepo(Project project, String svnUrl, String path) {
        this.project = project
        this.svnUrl = svnUrl
        this.path = path
        // Working directory
        wd = "/var/lib/jenkins/tests/svn-wd/${path}"
        project.dockerSsh "mkdir -p ${wd}"
        // Creation of the parent path
        svnCommand "mkdir --parents ${svnUrl}/${path} --message 'Creation of ${path}'"
        // Checks the URL out into the working directory
        svnCommand "checkout ${svnUrl}/${path} ."
    }

    void svnCommand (String command) {
        project.dockerSsh "cd ${wd} && svn --username ci --password test --no-auth-cache --non-interactive ${command}"
    }

    void svnCopy (String resource, String destination) {
        String dir = destination.split('/')[0..-2].join('/')
        project.dockerSsh "mkdir -p ${wd}/${dir} && cp /var/test/resources/${resource} ${wd}/${destination}"
        svnCommand "add --parents ${destination}"
    }

    void svnCommit (String message) {
        svnCommand "commit --message '${message}'"
    }
}

ext {
    dockerSsh = { String command ->
        def cid = project.tasks.dockerDeploy.cid()
        exec {
            executable = 'docker'
            args = ['exec', cid, '/bin/bash', '-c', command]
        }
    }
    dockerAsyncSsh = { String command ->
        def cid = project.tasks.dockerDeploy.cid()
        exec {
            executable = 'docker'
            args = ['exec', '--detach', cid, '/bin/bash', '-c', command]
        }
    }
    dockerScript = { String dir, String script ->
        dockerSsh "mkdir -p ${dir}"
        script.readLines().findAll { it.trim() }.each { String command ->
            dockerSsh "cd ${dir} && ${command.trim()}"
        }
    }
    dockerGitRepo = { String name, String script ->
        dockerScript "/var/lib/jenkins/tests/git/${name}", script
    }
}

task dockerSvnTestRepoSetup(dependsOn: dockerDeploy) {
    doFirst {
        def svnrepo = "/var/lib/jenkins/tests/svn"
        dockerScript svnrepo, '''\
rm -rf *
svnadmin create .
cp -r /var/test/resources/svn/* conf
'''
        dockerAsyncSsh "svnserve --daemon --root ${svnrepo} --pid-file ${svnrepo}/svn.pid"
    }
}

task dockerSvnTestRepos(dependsOn: dockerSvnTestRepoSetup) {
    doFirst {
        // Creation of all the needed paths and files for the acceptance tests
        // - 'Creating a project tree based of full customisation'
        new SvnRepo(project, 'PRJ/branches/R11.7.0').with {
            svnCopy 'seed-custom.properties', 'seed/seed.properties'
            svnCommit 'Seed properties'
        }
    }
}

tasks.addRule("Pattern: dockerGitTestRepoSeed<ID>") { String taskName ->
    if (taskName.startsWith("dockerGitTestRepoSeed")) {
        def id = (taskName - 'dockerGitTestRepoSeed').toLowerCase()
        task(taskName) {
            doFirst {
                dockerGitRepo "seed-${id}", """\
git init
git config user.email "acceptance-test@nemerosa.com"
git config user.name "Acceptance Test"
mkdir seed
echo "Is there any /var/test/resources/seed-${id}.groovy file?"
if [ -f /var/test/resources/seed-${id}.groovy ]; then echo "Copying /var/test/resources/seed-${id}.groovy"; cp /var/test/resources/seed-${id}.groovy seed/seed.groovy; fi
echo "Is there any /var/test/resources/seed-${id}.properties file?"
if [ -f /var/test/resources/seed-${id}.properties ]; then echo "Copying /var/test/resources/seed-${id}.properties"; cp /var/test/resources/seed-${id}.properties seed/seed.properties; fi
echo "Scheduling files for commit"
git add -A
echo "Committing the files"
git commit -m "Seed file(s)"
        """
            }
        }
    }
}

task dockerGitTestRepos(dependsOn: [
        dockerGitTestRepoSeedStd,
        dockerGitTestRepoSeedEnv,
        dockerGitTestRepoSeedScm,
        dockerGitTestRepoSeedCi,
        dockerGitTestRepoSeedCred,
])

task dockerPrepareTestEnv(dependsOn: [dockerDeploy, dockerGitTestRepos, dockerSvnTestRepos])

// Local Docker acceptance tests orchestration

task localDockerAcceptanceTest {
    dependsOn buildLatest
    dependsOn dockerPrepareTestEnv
    dependsOn acceptanceTest
    finalizedBy dockerLogs
    finalizedBy dockerUndeploy
}

acceptanceTest.mustRunAfter dockerDeploy
acceptanceTest.mustRunAfter dockerGitTestRepos
acceptanceTest.mustRunAfter dockerSvnTestRepos
dockerGitTestRepos.mustRunAfter dockerDeploy
dockerSvnTestRepos.mustRunAfter dockerDeploy
dockerUndeploy.mustRunAfter dockerLogs
